document.addEventListener("DOMContentLoaded", () => {
  // --- DOM Elements ---
  const body = document.body;
  const mainContent = document.querySelector('.main-content');
  const typingForm = document.querySelector(".typing-form");
  const typingInput = document.querySelector(".typing-input");
  const chatContainer = document.querySelector(".chat-list");
  const sidebarToggleBtn = document.querySelector("#sidebar-toggle-button");
  const settingsBtn = document.querySelector("#settings-button");
  const settingsOverlay = document.querySelector("#settings-panel-overlay");
  const closeSettingsBtn = document.querySelector(".close-settings-panel");
  const saveSettingsBtn = document.querySelector("#save-settings-btn");
  const sessionList = document.querySelector(".chat-session-list");
  const newSessionBtn = document.querySelector(".new-session-button");
  const stopGenerationBtn = document.querySelector("#stop-generation-btn");
  const sessionSearchInput = document.querySelector("#session-search");
  const settingsNavItems = document.querySelectorAll(".settings-nav-item");
  const settingsContents = document.querySelectorAll(".settings-content");
  const settingsTitle = document.querySelector("#settings-title");
  const welcomeTitleEl = document.getElementById("welcome-title");
  const welcomeSubtitleEl = document.getElementById("welcome-subtitle");
  const welcomeSuggestionsEl = document.getElementById("welcome-suggestions");
  const disclaimerEl = document.getElementById("disclaimer-text-element");
  // const attachFileBtn = document.getElementById('attach-file-btn');
  const fileInput = document.getElementById('file-input');
  const filePreviewContainer = document.getElementById('file-preview-container');
  const scanModelsBtn = document.getElementById('scan-ollama-models-btn');
  const addModelBtn = document.getElementById('add-custom-model-btn');
  const deleteModelBtn = document.getElementById('delete-selected-model-btn');
  const modelScanStatus = document.getElementById('model-scan-status');

  // --- State Variables ---
  let isGenerating = false;
  let currentSessionId = null;
  let settings = {};
  let sessions = {};
  let feedback = [];
  let abortController = null;
  let attachedFiles = [];

  // --- Initialization ---
  const initialize = () => {
    loadSettings();
    configureDOMPurify(); // Configure DOMPurify hooks
    configureMarked(); // Configure marked after settings are loaded
    loadFeedback();
    applyTheme();
    applyUISettings();
    loadSessions();
    if (!currentSessionId || !sessions[currentSessionId]) {
      createNewSession();
    }
    switchSession(currentSessionId);
    addEventListeners();
    resizeTextarea();
  };

  // --- NEW: Configure DOMPurify to handle links ---
  const configureDOMPurify = () => {
    // This hook ensures all links generated by Markdown will open in a new tab.
    DOMPurify.addHook('afterSanitizeElements', (node) => {
      if (node.tagName === 'A') {
        node.setAttribute('target', '_blank');
        node.setAttribute('rel', 'noopener noreferrer');
      }
    });
  };

  // --- MODIFIED: Configure marked to use highlight.js based on settings ---
  const configureMarked = () => {
    marked.setOptions({
      highlight: function(code, lang) {
        if (settings.syntaxHighlighting) {
          const language = hljs.getLanguage(lang) ? lang : 'plaintext';
          return hljs.highlight(code, {
            language,
            ignoreIllegals: true
          }).value;
        }
        // Return plain, escaped code if highlighting is off
        return code.replace(/</g, "&lt;").replace(/>/g, "&gt;");
      },
      gfm: true,
      breaks: true
    });
  };

  const addEventListeners = () => {
    sidebarToggleBtn.addEventListener("click", toggleSidebar);
    newSessionBtn.addEventListener("click", createNewSession);
    typingForm.addEventListener("submit", (e) => handleSendMessage(e, {}));
    typingInput.addEventListener("input", resizeTextarea);
    typingInput.addEventListener("keydown", handleEnterKey);
    settingsBtn.addEventListener("click", openSettingsPanel);
    closeSettingsBtn.addEventListener("click", closeSettingsPanel);
    settingsOverlay.addEventListener("click", (e) => {
      if (e.target === settingsOverlay) closeSettingsPanel();
    });
    saveSettingsBtn.addEventListener("click", saveAndApplySettings);
    stopGenerationBtn.addEventListener("click", stopGeneration);
    sessionSearchInput.addEventListener("input", renderSessionList); 
    // attachFileBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', handleFileSelect);

    addEventListenersForDragDrop();

    document.addEventListener('keydown', (e) => {
      if (e.key === "Escape" && body.classList.contains("settings-open")) {
        closeSettingsPanel();
      }
    });

    document.addEventListener('contextmenu', (event) => {
      const target = event.target;
      const isInput = target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable || target.closest('pre');
      if (!isInput) {
        event.preventDefault();
      }
    });

    settingsNavItems.forEach(item => {
      item.addEventListener("click", () => {
        const section = item.dataset.section;
        settingsNavItems.forEach(i => i.classList.remove("active"));
        settingsContents.forEach(c => c.classList.remove("active"));
        item.classList.add("active");
        const contentEl = document.getElementById(`${section}-settings`);
        contentEl.classList.add("active");
        settingsTitle.textContent = item.querySelector("span:last-child").textContent;

        if (section === 'feedback') {
          renderFeedbackTab();
        }
      });
    });

    document.querySelectorAll(".theme-toggle-switch button").forEach(button => {
      button.addEventListener("click", () => {
        settings.theme = button.dataset.theme;
        applyTheme();
        document.querySelectorAll(".theme-toggle-switch button").forEach(b => {
          b.classList.toggle("active", b.dataset.theme === settings.theme);
        });
      });
    });

    document.getElementById("temperature").addEventListener("input", e => {
      document.getElementById("temperature-value").textContent = e.target.value;
    });
    document.getElementById("show-disclaimer").addEventListener("change", e => {
      document.getElementById("custom-disclaimer-group").style.display = e.target.checked ? 'flex' : 'none';
    });
    document.getElementById("export-settings-btn").addEventListener("click", exportSettings);
    document.getElementById("import-settings-btn").addEventListener("click", importSettings);
    document.getElementById("export-all-chats-btn").addEventListener("click", exportAllChats);
    document.getElementById("import-all-chats-btn").addEventListener("click", importAllChats);
    document.getElementById("clear-all-chats-btn").addEventListener("click", clearAllChats);
    document.getElementById("font-size").addEventListener("change", e => {
      settings.fontSize = e.target.value;
      applyUISettings();
    });
    document.getElementById("compact-mode").addEventListener("change", e => {
      settings.compactMode = e.target.checked;
      applyUISettings();
    });

    scanModelsBtn.addEventListener('click', scanOllamaModels);
    addModelBtn.addEventListener('click', addCustomModel);
    deleteModelBtn.addEventListener('click', deleteSelectedModel);
  };

  // --- Model Management ---
  const populateModelDropdown = () => {
    const modelSelect = document.getElementById('model');
    const allModels = settings.customModels || [];

    modelSelect.innerHTML = ''; // Clear existing options

    if (allModels.length === 0) {
      modelSelect.innerHTML = '<option value="">Please scan or add the model first.</option>';
    } else {
      allModels.forEach(modelName => {
        const option = document.createElement('option');
        option.value = modelName;
        option.textContent = modelName;
        modelSelect.appendChild(option);
      });
    }

    if (settings.model && allModels.includes(settings.model)) {
      modelSelect.value = settings.model;
    } else if (allModels.length > 0) {
      // If current model isn't valid, select the first one
      modelSelect.value = allModels[0];
      settings.model = allModels[0];
    } else {
      // No models available
      settings.model = "";
    }
  };

  const scanOllamaModels = async () => {
    const apiEndpoint = document.getElementById('api-endpoint').value.trim();
    if (!apiEndpoint) {
      showToast("请先设置API端点。", "error");
      return;
    }

    let tagsUrl;
    try {
      // Construct the '/api/tags' URL from the chat endpoint (e.g., http://host:port/api/chat -> http://host:port/api/tags)
      const url = new URL(apiEndpoint);
      tagsUrl = `${url.protocol}//${url.host}/api/tags`;
    } catch (e) {
      showToast("无效的API端点URL。", "error");
      return;
    }

    modelScanStatus.textContent = '正在扫描...';
    try {
      const response = await fetch(tagsUrl);
      if (!response.ok) {
        throw new Error(`无法连接到Ollama: ${response.statusText}`);
      }
      const data = await response.json();

      if (!data.models || !Array.isArray(data.models)) {
        throw new Error(`从Ollama返回的格式无效。`);
      }

      const modelNames = data.models.map(m => m.name);

      const currentModels = new Set(settings.customModels || []);
      modelNames.forEach(name => currentModels.add(name));
      settings.customModels = Array.from(currentModels).sort();

      saveSettings();
      populateModelDropdown();

      if (!settings.model && settings.customModels.length > 0) {
        document.getElementById('model').value = settings.customModels[0];
      }

      modelScanStatus.textContent = `扫描完成！找到 ${modelNames.length} 个新模型。`;
      showToast("本地模型扫描成功！", "success");
    } catch (error) {
      console.error("Error scanning Ollama models:", error);
      modelScanStatus.textContent = '扫描失败。';
      showToast(`扫描失败: ${error.message}`, "error");
    }
  };

  const addCustomModel = () => {
    showPrompt("输入自定义模型名称:", "", (newModel) => {
      if (newModel && newModel.trim() !== "") {
        const modelName = newModel.trim();
        if (!settings.customModels) {
          settings.customModels = [];
        }
        if (settings.customModels.includes(modelName)) {
          showToast("该模型已存在。", "info");
          return;
        }
        settings.customModels.push(modelName);
        settings.customModels.sort();
        saveSettings();
        populateModelDropdown();
        document.getElementById('model').value = modelName; // Select the new model
        showToast(`模型 "${modelName}" 已添加。`, "success");
      }
    });
  };

  const deleteSelectedModel = () => {
    const modelSelect = document.getElementById('model');
    const modelToDelete = modelSelect.value;

    if (!modelToDelete || settings.customModels.length === 0) {
      showToast("No models can be deleted.", "error");
      return;
    }

    showConfirm(`确认删除模型 "${modelToDelete}"？`, "此操作无法撤销。", () => {
      const index = settings.customModels.indexOf(modelToDelete);
      if (index > -1) {
        settings.customModels.splice(index, 1);
        saveSettings();
        populateModelDropdown();
        showToast(`模型 "${modelToDelete}" 已删除。`, "success");
      } else {
        showToast("找不到要删除的模型。", "error");
      }
    });
  };

  // --- Feedback Management ---
  const loadFeedback = () => {
    feedback = JSON.parse(localStorage.getItem("ai-assistant-feedback")) || [];
  };

  const saveFeedback = () => {
    localStorage.setItem("ai-assistant-feedback", JSON.stringify(feedback));
  };

  const handleFeedback = (e) => {
    const button = e.currentTarget;
    const feedbackType = button.dataset.feedbackType;
    const messageIndex = parseInt(button.dataset.messageIndex, 10);
    const session = sessions[currentSessionId];
    const message = session?.history[messageIndex];

    if (message) {
      if (message.feedbackSubmitted) {
        showToast("You have already provided feedback.", "info");
        return;
      }

      feedback.push({
        sessionId: currentSessionId,
        messageIndex: messageIndex,
        messageContent: message.content,
        feedbackType: feedbackType,
        timestamp: Date.now()
      });
      saveFeedback();

      message.feedbackSubmitted = feedbackType;
      saveSessions();

      showToast("感谢您的反馈！", "success");
      renderChat();
    }
  };

  const renderFeedbackTab = () => {
    const container = document.getElementById('feedback-settings');
    container.innerHTML = '';

    if (!feedback || feedback.length === 0) {
      container.innerHTML = '<p style="text-align: center; color: var(--subheading-color); padding: 2rem 0;">No feedback records at this time.</p>';
      return;
    }

    const feedbackList = document.createElement('ul');
    feedbackList.className = 'feedback-list';

    feedback.slice().reverse().forEach(item => {
      const li = document.createElement('li');
      li.className = 'feedback-item';
      const icon = item.feedbackType === 'like' ? 'thumb_up' : 'thumb_down';
      const color = item.feedbackType === 'like' ? 'var(--success-color)' : 'var(--error-color)';
      li.innerHTML = `
		                    <div class="feedback-item-header">
		                        <span class="material-symbols-rounded" style="color: ${color};">${icon}</span>
		                        <span class="feedback-timestamp">${new Date(item.timestamp).toLocaleString()}</span>
		                    </div>
		                    <p class="feedback-message-content">${DOMPurify.sanitize(item.messageContent)}</p>
		                `;
      feedbackList.appendChild(li);
    });

    const clearFeedbackBtn = document.createElement('button');
    clearFeedbackBtn.id = 'clear-all-feedback-btn';
    clearFeedbackBtn.textContent = 'Clear all feedback';
    clearFeedbackBtn.className = 'glass-button error-button';
    clearFeedbackBtn.style.marginTop = '1.5rem';
    clearFeedbackBtn.style.width = '100%';

    clearFeedbackBtn.addEventListener('click', () => {
      showConfirm('确认清除所有反馈？', '此操作无法撤销。', () => {
        feedback = [];
        saveFeedback();
        Object.values(sessions).forEach(session => {
          session.history.forEach(message => {
            if (message.feedbackSubmitted) {
              delete message.feedbackSubmitted;
            }
          });
        });
        saveSessions();
        renderFeedbackTab();
        renderChat();
        showToast('所有反馈已清除。', 'success');
      });
    });

    container.appendChild(feedbackList);
    container.appendChild(clearFeedbackBtn);
  };

  // --- Settings Management ---
  const loadSettings = () => {
    const savedSettings = JSON.parse(localStorage.getItem("ai-assistant-settings")) || {};
    settings = {
      theme: savedSettings.theme || "dark-mode",
      settingsWindowed: savedSettings.settingsWindowed === true,
      apiKey: savedSettings.apiKey !== undefined ? savedSettings.apiKey : "",
      apiEndpoint: savedSettings.apiEndpoint !== undefined ? savedSettings.apiEndpoint : "http://localhost:11434/api/chat",
      model: savedSettings.model || "",
      customModels: savedSettings.customModels || [],
      maxContextLength: savedSettings.maxContextLength || 20,
      systemPrompt: savedSettings.systemPrompt !== undefined ? savedSettings.systemPrompt : "You are a helpful assistant.",
      temperature: savedSettings.temperature || 0.7,
      displayMarkdown: savedSettings.displayMarkdown !== false,
      showDialogueInfo: savedSettings.showDialogueInfo === true,
      enableStreaming: savedSettings.enableStreaming !== false,
      showThinkingProcess: savedSettings.showThinkingProcess !== false,
      autoRunCode: savedSettings.autoRunCode === true,
      autoScroll: savedSettings.autoScroll !== false,
      // --- NEW: Add syntax highlighting setting with default to true ---
      syntaxHighlighting: savedSettings.syntaxHighlighting !== false,
      fontSize: savedSettings.fontSize || "medium",
      compactMode: savedSettings.compactMode === true,
      showTimestamps: savedSettings.showTimestamps === true,
      showAvatars: savedSettings.showAvatars === true,
      enableAnimations: savedSettings.enableAnimations !== false,
      welcomeTitle: savedSettings.welcomeTitle !== undefined ? savedSettings.welcomeTitle : "Hello, there",
      welcomeSubtitle: savedSettings.welcomeSubtitle !== undefined ? savedSettings.welcomeSubtitle : "How can I help you today?",
      welcomeSuggestions: savedSettings.welcomeSuggestions !== undefined ? savedSettings.welcomeSuggestions : "",
      showDisclaimer: savedSettings.showDisclaimer === true,
      disclaimerText: savedSettings.disclaimerText !== undefined ? savedSettings.disclaimerText : "FloeLM may display inaccurate info, so double-check its responses."
    };
  };

  const saveSettings = () => {
    localStorage.setItem("ai-assistant-settings", JSON.stringify(settings));
  };

  const applyTheme = () => {
    if (settings.theme === "system-mode") {
      const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
      body.classList.toggle("light-mode", !prefersDark);
    } else {
      body.classList.toggle("light-mode", settings.theme === "light-mode");
    }
    document.querySelectorAll(".theme-toggle-switch button").forEach(button => {
      button.classList.toggle("active", button.dataset.theme === settings.theme);
    });
  };

  const populateSettingsForm = () => {
    document.getElementById("api-key").value = settings.apiKey;
    document.getElementById("api-endpoint").value = settings.apiEndpoint;

    populateModelDropdown();

    document.getElementById("max-context-length").value = settings.maxContextLength;
    document.getElementById("system-prompt").value = settings.systemPrompt;
    document.getElementById("temperature").value = settings.temperature;
    document.getElementById("temperature-value").textContent = settings.temperature;
    document.getElementById("display-markdown").checked = settings.displayMarkdown;
    document.getElementById("settings-windowed-mode").checked = settings.settingsWindowed;
    document.getElementById("show-dialogue-info").checked = settings.showDialogueInfo;
    document.getElementById("enable-streaming").checked = settings.enableStreaming;
    document.getElementById("show-thinking-process").checked = settings.showThinkingProcess;
    document.getElementById("auto-run-code").checked = settings.autoRunCode;
    document.getElementById("auto-scroll").checked = settings.autoScroll;
    // --- NEW: Populate new syntax highlighting toggle ---
    document.getElementById("syntax-highlighting").checked = settings.syntaxHighlighting;
    document.getElementById("font-size").value = settings.fontSize;
    document.getElementById("compact-mode").checked = settings.compactMode;
    document.getElementById("show-timestamps").checked = settings.showTimestamps;
    document.getElementById("show-avatars").checked = settings.showAvatars;
    document.getElementById("enable-animations").checked = settings.enableAnimations;
    document.getElementById("welcome-title-input").value = settings.welcomeTitle;
    document.getElementById("welcome-subtitle-input").value = settings.welcomeSubtitle;
    document.getElementById("welcome-suggestions-input").value = settings.welcomeSuggestions;

    const showDisclaimerCheckbox = document.getElementById("show-disclaimer");
    const customDisclaimerGroup = document.getElementById("custom-disclaimer-group");
    const customDisclaimerInput = document.getElementById("custom-disclaimer-input");
    showDisclaimerCheckbox.checked = settings.showDisclaimer;
    customDisclaimerInput.value = settings.disclaimerText;
    customDisclaimerGroup.style.display = settings.showDisclaimer ? 'flex' : 'none';

    applyTheme();
  };

  const saveAndApplySettings = () => {
    settings.apiKey = document.getElementById("api-key").value.trim();
    settings.apiEndpoint = document.getElementById("api-endpoint").value.trim();
    settings.model = document.getElementById("model").value;
    settings.maxContextLength = Math.min(100, Math.max(1, parseInt(document.getElementById("max-context-length").value) || 20));
    settings.systemPrompt = document.getElementById("system-prompt").value;
    settings.temperature = parseFloat(document.getElementById("temperature").value);
    settings.displayMarkdown = document.getElementById("display-markdown").checked;
    settings.settingsWindowed = document.getElementById("settings-windowed-mode").checked;
    settings.showDialogueInfo = document.getElementById("show-dialogue-info").checked;
    settings.enableStreaming = document.getElementById("enable-streaming").checked;
    settings.showThinkingProcess = document.getElementById("show-thinking-process").checked;
    settings.autoRunCode = document.getElementById("auto-run-code").checked;
    settings.autoScroll = document.getElementById("auto-scroll").checked;
    // --- NEW: Save new syntax highlighting setting ---
    settings.syntaxHighlighting = document.getElementById("syntax-highlighting").checked;
    settings.fontSize = document.getElementById("font-size").value;
    settings.compactMode = document.getElementById("compact-mode").checked;
    settings.showTimestamps = document.getElementById("show-timestamps").checked;
    settings.showAvatars = document.getElementById("show-avatars").checked;
    settings.enableAnimations = document.getElementById("enable-animations").checked;
    settings.welcomeTitle = document.getElementById("welcome-title-input").value.trim();
    settings.welcomeSubtitle = document.getElementById("welcome-subtitle-input").value.trim();
    settings.welcomeSuggestions = document.getElementById("welcome-suggestions-input").value.trim();
    settings.showDisclaimer = document.getElementById("show-disclaimer").checked;
    settings.disclaimerText = document.getElementById("custom-disclaimer-input").value.trim();

    saveSettings();
    // --- NEW: Re-configure marked to apply syntax highlighting changes immediately ---
    configureMarked();
    applyUISettings();
    closeSettingsPanel();
    showToast("设置已保存！", "success");
  };

  const applyUISettings = () => {
    body.classList.remove("font-size-small", "font-size-medium", "font-size-large");
    body.classList.add(`font-size-${settings.fontSize}`);
    body.classList.toggle("compact-mode", settings.compactMode);
    body.classList.toggle("show-avatars", settings.showAvatars);
    body.classList.toggle("animations-disabled", !settings.enableAnimations);
    settingsOverlay.classList.toggle("windowed-view", settings.settingsWindowed);
    welcomeTitleEl.textContent = settings.welcomeTitle;
    welcomeSubtitleEl.textContent = settings.welcomeSubtitle;
    renderWelcomeSuggestions();
    body.classList.toggle("show-disclaimer", settings.showDisclaimer);
    disclaimerEl.textContent = settings.disclaimerText;
    renderChat(); // Re-render chat to apply potential markdown/highlighting changes
  };

  const renderWelcomeSuggestions = () => {
    welcomeSuggestionsEl.innerHTML = "";
    const suggestions = settings.welcomeSuggestions.split("\n").filter(s => s.trim() !== "");
    suggestions.forEach(s => {
      const [text, icon] = s.split("|");
      if (!text || text.trim() === "") return;
      const suggestionText = text.trim();
      const suggestionIcon = icon ? icon.trim() : "lightbulb";
      const li = document.createElement("li");
      li.className = "suggestion";
      li.innerHTML = `
		                    <h4 class="text">${DOMPurify.sanitize(suggestionText)}</h4>
		                    <span class="icon material-symbols-rounded">${DOMPurify.sanitize(suggestionIcon)}</span>
		                `;
      li.addEventListener("click", handleSuggestionClick);
      welcomeSuggestionsEl.appendChild(li);
    });
  };

  const exportSettings = () => {
    const dataStr = JSON.stringify(settings, null, 2);
    const blob = new Blob([dataStr], {
      type: "application/json"
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "floe-lm-settings.json";
    body.appendChild(a);
    a.click();
    body.removeChild(a);
    URL.revokeObjectURL(url);
    showToast("设置已导出！", "success");
  };

  const importSettings = () => {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = "application/json";
    input.onchange = e => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const importedSettings = JSON.parse(event.target.result);
            const newSettings = {
              ...loadSettings(),
              ...importedSettings
            };
            settings = newSettings;
            saveSettings();
            populateSettingsForm();
            applyUISettings();
            showToast("设置导入成功！", "success");
          } catch (err) {
            console.error("Error importing settings:", err);
            showToast("导入设置失败: " + err.message, "error");
          }
        };
        reader.readAsText(file);
      }
    };
    input.click();
  };

  // --- Session Management ---
  const loadSessions = () => {
    sessions = JSON.parse(localStorage.getItem("ai-assistant-sessions")) || {};
    currentSessionId = localStorage.getItem("ai-assistant-current-session");
  };

  const saveSessions = () => {
    localStorage.setItem("ai-assistant-sessions", JSON.stringify(sessions));
    localStorage.setItem("ai-assistant-current-session", currentSessionId);
  };

  const switchSession = (sessionId) => {
    if (isGenerating) {
      showToast("AI正在回复中，请稍后切换。", "info");
      return;
    }
    if (sessions[sessionId]) {
      currentSessionId = sessionId;
      renderSessionList();
      renderChat();
      saveSessions();
    }
  };

  const createNewSession = () => {
    if (isGenerating) {
      showToast("AI正在回复中，请稍后新建。", "info");
      return;
    }
    const newId = `session_${Date.now()}`;
    sessions[newId] = {
      name: `Chat ${Object.keys(sessions).length + 1}`,
      history: [],
      pinned: false,
      timestamp: Date.now()
    };
    switchSession(newId);
  };

  const deleteSession = (e, sessionId) => {
    e.stopPropagation();
    showConfirm("确认删除对话？", "此操作无法撤销。", () => {
      if (Object.keys(sessions).length <= 1) {
        showToast("无法删除最后一个对话。", "error");
        return;
      }
      delete sessions[sessionId];
      const remainingIds = Object.keys(sessions).sort((a, b) => sessions[b].timestamp - sessions[a].timestamp);
      if (currentSessionId === sessionId) {
        switchSession(remainingIds[0]);
      } else {
        renderSessionList();
      }
      saveSessions();
      showToast("对话已删除。", "success");
    });
  };

  const renameSession = (e, sessionId) => {
    e.stopPropagation();
    showPrompt("Enter a new conversation name:", sessions[sessionId].name, (newName) => {
      if (newName && newName.trim() !== "") {
        sessions[sessionId].name = newName.trim();
        saveSessions();
        renderSessionList();
        showToast("对话名称已更新。", "success");
      }
    });
  };

  const pinSession = (e, sessionId) => {
    e.stopPropagation();
    sessions[sessionId].pinned = !sessions[sessionId].pinned;
    saveSessions();
    renderSessionList();
    showToast(sessions[sessionId].pinned ? "对话已置顶。" : "对话已取消置顶。", "info");
  };

  const clearAllChats = () => {
    showConfirm("确认清除所有对话？", "此操作无法撤销，所有对话都将被删除。", () => {
      sessions = {};
      currentSessionId = null;
      saveSessions();
      createNewSession();
      showToast("所有对话已清除。", "success");
    });
  };

  const exportAllChats = () => {
    if (Object.keys(sessions).length === 0) {
      showToast("没有可导出的对话。", "error");
      return;
    }
    const dataStr = JSON.stringify(sessions, null, 2);
    const blob = new Blob([dataStr], {
      type: "application/json"
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.download = `floe-lm-chats-${new Date().toISOString().slice(0, 10)}.json`;
    a.href = url;
    body.appendChild(a);
    a.click();
    body.removeChild(a);
    URL.revokeObjectURL(url);
    showToast("所有对话已导出！", "success");
  };

  const importAllChats = () => {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = "application/json";
    input.onchange = e => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const importedSessions = JSON.parse(event.target.result);
            sessions = {
              ...sessions,
              ...importedSessions
            };
            saveSessions();
            const latestSessionId = Object.keys(sessions).sort((a, b) => sessions[b].timestamp - sessions[a].timestamp)[0];
            renderSessionList();
            if (latestSessionId) switchSession(latestSessionId);
            showToast("对话导入成功！", "success");
          } catch (err) {
            console.error("Error importing chats:", err);
            showToast("导入对话失败: " + err.message, "error");
          }
        };
        reader.readAsText(file);
      }
    };
    input.click();
  };

  // --- UI Rendering ---
  const renderSessionList = () => {
    sessionList.innerHTML = "";
    const searchTerm = sessionSearchInput.value.toLowerCase();

    const filtered = Object.entries(sessions).filter(([id, session]) => {
      const nameMatch = session.name.toLowerCase().includes(searchTerm);
      const historyMatch = session.history.some(msg => msg.content.toLowerCase().includes(searchTerm));
      return nameMatch || historyMatch;
    });

    const sorted = filtered.sort((a, b) => {
      const sessionA = a[1];
      const sessionB = b[1];
      if (sessionA.pinned !== sessionB.pinned) return sessionA.pinned ? -1 : 1;
      const lastMsgTimeA = sessionA.history.length > 0 ? sessionA.history[sessionA.history.length - 1].timestamp : sessionA.timestamp;
      const lastMsgTimeB = sessionB.history.length > 0 ? sessionB.history[sessionB.history.length - 1].timestamp : sessionB.timestamp;
      return lastMsgTimeB - lastMsgTimeA;
    });

    if (sorted.length === 0) {
      sessionList.innerHTML = `<li style="text-align: center; color: var(--subheading-color); padding: 1rem; user-select: none; border: none;">${searchTerm ? '无匹配对话' : '暂无对话'}</li>`;
      return;
    }

    for (const [id, session] of sorted) {
      const li = document.createElement("li");
      li.dataset.sessionId = id;
      if (id === currentSessionId) li.classList.add("active");
      if (session.pinned) li.classList.add("pinned-session");

      const pinIconClass = session.pinned ? 'pinned' : '';
      const pinIconTitle = session.pinned ? '置顶' : '取消置顶';

      li.innerHTML = `
		                    <span class="session-name">${DOMPurify.sanitize(session.name)}</span>
		                    <div class="session-actions">
		                        <span class="material-symbols-rounded pin-session ${pinIconClass}" title="${pinIconTitle}">push_pin</span>
		                        <span class="material-symbols-rounded rename-session" title="重命名对话">edit</span>
		                        <span class="material-symbols-rounded delete-session" title="删除对话">delete</span>
		                    </div>
		                `;
      li.addEventListener("click", () => switchSession(id));
      li.querySelector(".rename-session").addEventListener("click", (e) => renameSession(e, id));
      li.querySelector(".delete-session").addEventListener("click", (e) => deleteSession(e, id));
      li.querySelector(".pin-session").addEventListener("click", (e) => pinSession(e, id));
      sessionList.appendChild(li);
    }
  };

  const renderChat = () => {
    const session = sessions[currentSessionId];
    if (session) {
      chatContainer.innerHTML = "";
      session.history.forEach((message, index) => {
        const messageEl = createMessageElement(message, index);
        chatContainer.appendChild(messageEl);
      });
      body.classList.toggle("hide-header", session.history.length > 0);
      if (settings.autoScroll) {
        chatContainer.scrollTop = chatContainer.scrollHeight;
      }
    } else {
      chatContainer.innerHTML = "";
      body.classList.remove("hide-header");
    }
  };

  const parseThinkContent = (rawContent) => {
    const thinkRegex = /<think>([\s\S]*?)<\/think>/;
    const match = rawContent.match(thinkRegex);
    if (match) {
      const thinking = match[1].trim();
      const content = rawContent.replace(thinkRegex, "").trim();
      return {
        thinking,
        content
      };
    }
    return {
      thinking: null,
      content: rawContent
    };
  };

  const createMessageElement = (message, index) => {
    const {
      role,
      content,
      thinking,
      timestamp,
      feedbackSubmitted,
      dialogueInfo
    } = message;
    const wrapper = document.createElement("div");
    wrapper.className = `message ${role === 'user' ? 'outgoing' : 'incoming'}`;
    const avatarIcon = role === 'user' ? 'person' : 'smart_toy';

    const textDiv = document.createElement('div');
    textDiv.className = 'text';
    if (settings.displayMarkdown && role === 'assistant') {
      textDiv.innerHTML = DOMPurify.sanitize(marked.parse(content || ''));
      textDiv.classList.add('markdown-body');
    } else {
      const sanitizedContent = content.replace(/</g, "&lt;").replace(/>/g, "&gt;");
      textDiv.innerHTML = sanitizedContent.replace(/\n/g, '<br>');
    }

    let thinkingHTML = '';
    if (role === 'assistant' && thinking && settings.showThinkingProcess) {
      const thinkingContentHTML = DOMPurify.sanitize(marked.parse(thinking));
      thinkingHTML = `
		                    <div class="thinking-process">
		                        <div class="thinking-content-wrapper collapsed">
		                            <div class="thinking-header">
		                                <span class="material-symbols-rounded">expand_more</span>
		                                思考过程
		                            </div>
		                            <div class="thinking-content markdown-body">${thinkingContentHTML}</div>
		                        </div>
		                    </div>
		                `;
    }

    const timestampHTML = settings.showTimestamps && timestamp ?
      `<span class="timestamp" style="font-size: 0.75rem; color: var(--placeholder-color); margin-top: 0.25rem; display: block;">${new Date(timestamp).toLocaleString()}</span>` : '';

    const feedbackButtonsHTML = role === 'assistant' ? `
		                <button class="icon thumb-up ${feedbackSubmitted === 'like' ? 'active' : ''}" title="喜欢" data-feedback-type="like" data-message-index="${index}" ${feedbackSubmitted ? 'disabled' : ''}><span class="material-symbols-rounded">thumb_up</span></button>
		                <button class="icon thumb-down ${feedbackSubmitted === 'dislike' ? 'active' : ''}" title="不喜欢" data-feedback-type="dislike" data-message-index="${index}" ${feedbackSubmitted ? 'disabled' : ''}><span class="material-symbols-rounded">thumb_down</span></button>
		            ` : '';

    let dialogueInfoHTML = '';
    if (role === 'assistant' && dialogueInfo && settings.showDialogueInfo) {
      dialogueInfoHTML = `
		                    <div class="dialogue-info">
		                        <span><span class="material-symbols-rounded" style="font-size: inherit;">bolt</span> ${dialogueInfo.tokensPerSecond} token/s</span>
		                        <span><span class="material-symbols-rounded" style="font-size: inherit;">timer</span> ${dialogueInfo.timeToFirstToken}s (First response)</span>
		                        <span>${dialogueInfo.totalTime}s (总计)</span>
		                        <span>${dialogueInfo.model}</span>
		                    </div>
		                `;
    }

    wrapper.innerHTML = `
		                <div class="avatar"><span class="material-symbols-rounded">${avatarIcon}</span></div>
		                <div class="message-content">
		                    ${thinkingHTML}
		                    ${textDiv.outerHTML}
		                    ${timestampHTML}
		                    <div class="message-footer">
		                         ${dialogueInfoHTML}
		                        <div class="action-btns">
		                            ${role === 'user' ? `<button class="icon edit-prompt" title="Edit message"><span class="material-symbols-rounded">edit</span></button>` : ''}
		                            <button class="icon copy" title="Copy"><span class="material-symbols-rounded">content_copy</span></button>
		                            ${role === 'assistant' ? `<button class="icon regenerate" title="Regenerate"><span class="material-symbols-rounded">refresh</span></button>` : ''}
		                            ${feedbackButtonsHTML}
		                        </div>
		                    </div>
		                </div>
		            `;

    wrapper.querySelectorAll('pre').forEach(pre => {
      const copyBtn = document.createElement('button');
      copyBtn.className = 'copy-code-btn';
      copyBtn.innerHTML = `<span class="material-symbols-rounded">content_copy</span><span>Copy</span>`;
      copyBtn.title = 'Copy code';

      copyBtn.addEventListener('click', () => {
        const codeToCopy = pre.querySelector('code').textContent;
        navigator.clipboard.writeText(codeToCopy).then(() => {
          copyBtn.querySelector('span:last-child').textContent = 'Copied!';
          setTimeout(() => {
            copyBtn.querySelector('span:last-child').textContent = 'Copy';
          }, 2000);
        }).catch(err => {
          showToast('Failed to copy code.', 'error');
          console.error('Copy failed', err);
        });
      });
      pre.appendChild(copyBtn);
    });

    wrapper.querySelector(".copy").addEventListener("click", () => copyToClipboard(content));

    if (role === 'assistant') {
      wrapper.querySelector(".regenerate")?.addEventListener("click", () => regenerateResponse(index));
      wrapper.querySelectorAll('.thumb-up, .thumb-down').forEach(btn => {
        btn.addEventListener('click', handleFeedback);
      });
      const thinkingHeader = wrapper.querySelector('.thinking-header');
      if (thinkingHeader) {
        thinkingHeader.addEventListener('click', (e) => {
          e.currentTarget.parentElement.classList.toggle('collapsed');
        });
      }
    }

    if (role === 'user') {
      wrapper.querySelector(".edit-prompt")?.addEventListener("click", () => editMessage(index));
    }

    return wrapper;
  };

  // --- File Handling ---
  const addEventListenersForDragDrop = () => {
    let dragCounter = 0;

    mainContent.addEventListener('dragenter', (e) => {
      e.preventDefault();
      e.stopPropagation();
      dragCounter++;
      mainContent.classList.add('drag-over');
    });

    mainContent.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.stopPropagation();
    });

    mainContent.addEventListener('dragleave', (e) => {
      e.preventDefault();
      e.stopPropagation();
      dragCounter--;
      if (dragCounter === 0) {
        mainContent.classList.remove('drag-over');
      }
    });

    mainContent.addEventListener('drop', (e) => {
      e.preventDefault();
      e.stopPropagation();
      dragCounter = 0;
      mainContent.classList.remove('drag-over');

      const files = e.dataTransfer.files;
      if (files && files.length > 0) {
        handleFiles(files);
      }
    });
  };

  const handleFileSelect = (event) => {
    const files = event.target.files;
    if (files && files.length > 0) {
      handleFiles(files);
    }
    fileInput.value = '';
  };

  const handleFiles = (files) => {
    for (const file of files) {
      attachedFiles.push(file);
    }
    renderFilePreview();
  };

  const renderFilePreview = () => {
    filePreviewContainer.innerHTML = '';
    body.classList.toggle('has-files', attachedFiles.length > 0);
    if (attachedFiles.length > 0) {
      attachedFiles.forEach((file, index) => {
        const chip = document.createElement('div');
        chip.className = 'file-chip';
        chip.innerHTML = `
		                        <span>${DOMPurify.sanitize(file.name)}</span>
		                        <button class="remove-file-btn" data-index="${index}" title="Remove file"><span class="material-symbols-rounded">close</span></button>
		                    `;
        chip.querySelector('.remove-file-btn').addEventListener('click', removeAttachedFile);
        filePreviewContainer.appendChild(chip);
      });
    }
  };

  const removeAttachedFile = (event) => {
    const index = parseInt(event.currentTarget.dataset.index, 10);
    if (!isNaN(index)) {
      attachedFiles.splice(index, 1);
      renderFilePreview();
    }
  };

  const clearAttachedFiles = () => {
    attachedFiles = [];
    renderFilePreview();
  };

  const processFile = (file) => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        let fileContentHTML = '';
        if (file.type.startsWith('image/')) {
          fileContentHTML = `<br><img src="${e.target.result}" alt="${file.name}" class="attached-image">`;
        } else if (file.type.startsWith('text/')) {
          const textContent = e.target.result;
          const sanitizedText = textContent.replace(/</g, "&lt;").replace(/>/g, "&gt;");
          fileContentHTML = `\n\n--- ${file.name} ---\n<div class="attached-file-content">${sanitizedText}</div>`;
        } else {
          fileContentHTML = `\n\n[File Attached: ${file.name}]`;
        }
        resolve(fileContentHTML);
      };
      reader.onerror = (error) => reject(error);

      if (file.type.startsWith('image/')) {
        reader.readAsDataURL(file);
      } else {
        reader.readAsText(file);
      }
    });
  };

  // --- Chat Logic ---
  const handleSendMessage = async (event, options = {}) => {
    event?.preventDefault();

    if (!settings.model) {
      showToast("请在设置中选择或添加一个模型。", "error");
      return;
    }

    const {
      overridePrompt,
      isRegeneration = false
    } = options;
    let userPrompt = (overridePrompt || typingInput.value).trim();

    if ((!userPrompt && attachedFiles.length === 0) || isGenerating) return;

    const requestSessionId = currentSessionId;

    isGenerating = true;
    abortController = new AbortController();
    toggleStopButton(true);

    const startTime = Date.now();
    let firstChunkTime = null;
    const onFirstChunk = () => {
      if (!firstChunkTime) {
        firstChunkTime = Date.now();
      }
    };

    try {
      if (!isRegeneration && attachedFiles.length > 0) {
        const fileProcessingPromises = attachedFiles.map(file => processFile(file));
        const fileHTMLs = await Promise.all(fileProcessingPromises);
        userPrompt += fileHTMLs.join('');
      }

      typingInput.value = "";
      resizeTextarea();
      clearAttachedFiles();

      if (!isRegeneration) {
        sessions[requestSessionId].history.push({
          role: "user",
          content: userPrompt,
          timestamp: Date.now()
        });
        if (sessions[requestSessionId].history.length === 1 && sessions[requestSessionId].name.startsWith("Chat ")) {
          const plainTextPrompt = userPrompt.replace(/<[^>]*>?/gm, '');
          sessions[requestSessionId].name = plainTextPrompt.substring(0, 30) || "Chat";
          renderSessionList();
        }
      }

      saveSessions();
      renderChat();

      const tempAssistantMsgEl = createMessageElement({
        role: "assistant",
        content: '<div class="loading-indicator"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>'
      });
      chatContainer.appendChild(tempAssistantMsgEl);
      if (settings.autoScroll) {
        chatContainer.scrollTop = chatContainer.scrollHeight;
      }

      const rawResponse = await getAIResponse(requestSessionId, tempAssistantMsgEl, onFirstChunk);
      const {
        thinking,
        content
      } = parseThinkContent(rawResponse);

      const endTime = Date.now();
      const totalTime = (endTime - startTime) / 1000;
      const timeToFirstToken = firstChunkTime ? ((firstChunkTime - startTime) / 1000).toFixed(2) : (totalTime / 3).toFixed(2);
      const simulatedTokenCount = (rawResponse.length / 4);
      const tokensPerSecond = totalTime > 0 ? (simulatedTokenCount / totalTime).toFixed(1) : "N/A";

      const dialogueInfo = {
        tokensPerSecond: tokensPerSecond,
        timeToFirstToken: timeToFirstToken,
        totalTime: totalTime.toFixed(2),
        model: settings.model
      };

      sessions[requestSessionId].history.push({
        role: "assistant",
        content,
        thinking,
        timestamp: Date.now(),
        dialogueInfo: dialogueInfo
      });

    } catch (error) {
      if (error.name === 'AbortError') {
        const tempAssistantMsgEl = chatContainer.querySelector('.message:last-child .text');
        const {
          thinking,
          content
        } = parseThinkContent(tempAssistantMsgEl?.innerHTML || "");

        const dialogueInfo = {
          tokensPerSecond: "N/A",
          timeToFirstToken: "N/A",
          totalTime: "Stopped",
          model: settings.model
        };

        sessions[requestSessionId].history.push({
          role: "assistant",
          content: content || "已停止生成。",
          thinking,
          timestamp: Date.now(),
          dialogueInfo: dialogueInfo
        });
        showToast("生成已停止。", "info");
      } else {
        console.error("Error sending message:", error);
        sessions[requestSessionId].history.push({
          role: "assistant",
          content: `抱歉，出错了: ${error.message}`,
          timestamp: Date.now()
        });
        showToast(`Error: ${error.message}`, "error");
      }
    } finally {
      isGenerating = false;
      toggleStopButton(false);
      saveSessions();
      renderChat();
    }
  };

  const getAIResponse = async (requestSessionId, messageElement, onFirstChunk) => {
    const textElement = messageElement.querySelector('.text');
    let fullResponse = "";

    if (!settings.apiEndpoint) throw new Error("API端点未设置。请在设置中添加。");
    if (!settings.model) throw new Error("模型未选择。请在设置中选择一个模型。");

    const history = (sessions[requestSessionId]?.history || [])
      .filter(msg => msg.role !== 'error')
      .slice(-settings.maxContextLength);

    const messages = [{
        role: "system",
        content: settings.systemPrompt
      },
      ...history.map(msg => ({
        role: msg.role,
        content: msg.content.replace(/<[^>]*>?/gm, '')
      })),
    ];

    const body = {
      model: settings.model,
      messages: messages,
      stream: settings.enableStreaming,
      options: {
        temperature: settings.temperature
      }
    };

    const headers = {
      "Content-Type": "application/json"
    };
    if (settings.apiKey) {
      headers.Authorization = `Bearer ${settings.apiKey}`;
    }

    const response = await fetch(settings.apiEndpoint, {
      method: "POST",
      headers: headers,
      body: JSON.stringify(body),
      signal: abortController.signal,
    });

    if (!response.ok) {
      const errorText = await response.text();
      try {
        const errorData = JSON.parse(errorText);
        throw new Error(errorData.error?.message || errorData.error || `API 错误: ${response.status} ${response.statusText}`);
      } catch (e) {
        throw new Error(errorText || `API 错误: ${response.status} ${response.statusText}`);
      }
    }

    if (settings.enableStreaming && response.body) {
      let thinkingProcessRendered = false;
      textElement.innerHTML = "";
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';

      while (true) {
        const {
          done,
          value
        } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, {
          stream: true
        });
        const lines = buffer.split('\n');
        buffer = lines.pop();

        for (const line of lines) {
          if (currentSessionId !== requestSessionId) {
            try {
              const dataStr = line.replace(/^data: /, '').trim();
              if (dataStr.length > 0 && dataStr !== '[DONE]') {
                const data = JSON.parse(dataStr);
                const chunk = data.choices ? (data.choices[0]?.delta?.content || "") : (data.message?.content || "");
                fullResponse += chunk;
              }
            } catch (e) {
              /* ignore parsing errors */
            }
            continue;
          }

          if (line.trim().length === 0) continue;
          const dataStr = line.replace(/^data: /, '').trim();
          if (dataStr === '[DONE]') {
            return fullResponse;
          }
          try {
            const data = JSON.parse(dataStr);
            const chunk = data.choices ? (data.choices[0]?.delta?.content || "") : (data.message?.content || "");
            if (chunk) {
              onFirstChunk();
              fullResponse += chunk;

              const {
                thinking,
                content
              } = parseThinkContent(fullResponse);

              if (thinking && !thinkingProcessRendered && settings.showThinkingProcess) {
                thinkingProcessRendered = true;
                const thinkingHTML = `
		                                        <div class="thinking-process">
		                                            <div class="thinking-content-wrapper collapsed">
		                                                <div class="thinking-header">
		                                                    <span class="material-symbols-rounded">expand_more</span>
		                                                    思考过程
		                                                </div>
		                                                <div class="thinking-content markdown-body"></div>
		                                            </div>
		                                        </div>`;
                messageElement.querySelector('.message-content').insertAdjacentHTML('afterbegin', thinkingHTML);
                messageElement.querySelector('.thinking-header').addEventListener('click', (e) => {
                  e.currentTarget.parentElement.classList.toggle('collapsed');
                });
              }

              if (thinkingProcessRendered) {
                const thinkingContentEl = messageElement.querySelector('.thinking-content');
                if (thinkingContentEl) thinkingContentEl.innerHTML = DOMPurify.sanitize(marked.parse(thinking || ' '));
              }

              if (settings.displayMarkdown) {
                textElement.innerHTML = DOMPurify.sanitize(marked.parse(content || ' '));
                textElement.querySelectorAll('pre:not(:has(.copy-code-btn))').forEach(pre => {
                  const copyBtn = document.createElement('button');
                  copyBtn.className = 'copy-code-btn';
                  copyBtn.innerHTML = `<span class="material-symbols-rounded">content_copy</span><span>Copy</span>`;
                  copyBtn.addEventListener('click', () => {
                    navigator.clipboard.writeText(pre.querySelector('code').textContent);
                    copyBtn.querySelector('span:last-child').textContent = 'Copied!';
                    setTimeout(() => copyBtn.querySelector('span:last-child').textContent = 'Copy', 2000);
                  });
                  pre.appendChild(copyBtn);
                });
              } else {
                textElement.textContent = content;
              }
              if (settings.autoScroll) {
                chatContainer.scrollTop = chatContainer.scrollHeight;
              }
            }
          } catch (e) {
            console.error("Error parsing stream data:", e, "Data string:", dataStr);
          }
        }
      }
      return fullResponse;
    } else {
      const data = await response.json();
      fullResponse = data.choices ? (data.choices[0]?.message?.content.trim() || "") : (data.message?.content.trim() || "抱歉，我无法获取响应。");
      onFirstChunk();
      return fullResponse;
    }
  };

  const regenerateResponse = (messageIndex) => {
    const userMessageIndex = messageIndex - 1;
    if (userMessageIndex < 0 || isGenerating) return;

    const userPrompt = sessions[currentSessionId].history[userMessageIndex].content;
    sessions[currentSessionId].history.splice(userMessageIndex + 1);
    handleSendMessage(null, {
      overridePrompt: userPrompt,
      isRegeneration: true
    });
  };

  const editMessage = (index) => {
    if (isGenerating) return;
    const originalContent = sessions[currentSessionId].history[index].content;
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = originalContent;
    const plainTextContent = tempDiv.textContent || tempDiv.innerText || "";

    showPrompt("编辑您的消息:", plainTextContent, (newContent) => {
      if (newContent && newContent.trim() !== "" && newContent.trim() !== plainTextContent.trim()) {
        sessions[currentSessionId].history.splice(index);
        handleSendMessage(null, {
          overridePrompt: newContent.trim()
        });
      }
    });
  };

  // --- UI Helpers ---
  const toggleSidebar = () => {
    body.classList.toggle("sidebar-closed");
    body.classList.toggle("sidebar-open");
  };

  const openSettingsPanel = () => {
    populateSettingsForm();
    body.classList.add("settings-open");
    settingsOverlay.style.display = 'flex';
    const activeNavItem = document.querySelector(".settings-nav-item.active") || document.querySelector(".settings-nav-item");
    if (activeNavItem) activeNavItem.click();
  };

  const closeSettingsPanel = () => {
    body.classList.remove("settings-open");
    settingsOverlay.style.display = 'none';
  };

  const handleSuggestionClick = (e) => {
    const prompt = e.currentTarget.querySelector(".text").textContent;
    typingInput.value = prompt;
    handleSendMessage(new Event('submit'), {});
  };

  const handleEnterKey = (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      typingForm.dispatchEvent(new Event("submit", {
        cancelable: true,
        bubbles: true
      }));
    }
  };

  const resizeTextarea = () => {
    typingInput.style.height = "auto";
    typingInput.style.height = `${typingInput.scrollHeight}px`;
  };

  const copyToClipboard = (text) => {
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = text;
    const plainText = tempDiv.textContent || tempDiv.innerText || "";

    navigator.clipboard.writeText(plainText)
      .then(() => showToast("已复制到剪贴板！", "success"))
      .catch(err => {
        console.error("Failed to copy: ", err);
        showToast("复制失败！", "error");
      });
  };

  const stopGeneration = () => {
    if (abortController) {
      abortController.abort();
    }
  };

  const toggleStopButton = (showStop) => {
    const sendBtn = document.getElementById("send-message-button");
    const stopBtn = document.getElementById("stop-generation-btn");
    if (showStop) {
      sendBtn.style.display = 'none';
      stopBtn.style.display = 'flex';
    } else {
      sendBtn.style.display = 'flex';
      stopBtn.style.display = 'none';
    }
  };

  // --- Modals and Toasts ---
  const createModal = (type, title, message, callback = null, defaultValue = "") => {
    const modalPlaceholder = document.getElementById("custom-modal-placeholder");
    const existingModal = document.getElementById("custom-modal-overlay");
    if (existingModal) existingModal.remove();

    const overlay = document.createElement("div");
    overlay.id = "custom-modal-overlay";
    const content = document.createElement("div");
    content.classList.add("modal-content");
    content.innerHTML = `
		                <h4>${DOMPurify.sanitize(title)}</h4>
		                <p>${DOMPurify.sanitize(message)}</p>
		                ${type === 'prompt' ? `<textarea class="modal-input glass-input" rows="4"></textarea>` : ''}
		                <div class="modal-buttons">
		                    ${type !== 'alert' ? '<button class="modal-cancel-btn">取消</button>' : ''}
		                    <button class="modal-confirm-btn">${type === 'alert' ? '确定' : '确认'}</button>
		                </div>
		            `;

    const input = content.querySelector(".modal-input");
    if (input) {
      input.value = defaultValue;
    }

    overlay.appendChild(content);
    modalPlaceholder.appendChild(overlay);

    setTimeout(() => overlay.classList.add("show"), 10);

    const confirmBtn = content.querySelector(".modal-confirm-btn");
    const cancelBtn = content.querySelector(".modal-cancel-btn");

    let handleEsc;

    const closeModal = () => {
      overlay.classList.remove("show");
      overlay.addEventListener("transitionend", () => overlay.remove(), {
        once: true
      });
      document.removeEventListener('keydown', handleEsc);
    };

    handleEsc = (e) => {
      if (e.key === "Escape") closeModal();
    };
    document.addEventListener('keydown', handleEsc);

    confirmBtn.addEventListener("click", () => {
      if (callback) {
        type === 'prompt' ? callback(input.value) : callback();
      }
      closeModal();
    });

    if (cancelBtn) cancelBtn.addEventListener("click", closeModal);
    overlay.addEventListener("click", e => {
      if (e.target === overlay) closeModal();
    });
    if (input) {
      input.focus();
      input.select();
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          confirmBtn.click();
        }
      });
    }
  };

  const showToast = (message, type = "info", duration = 3000) => {
    const container = document.getElementById("toast-container") || (() => {
      const c = document.createElement("div");
      c.id = "toast-container";
      body.appendChild(c);
      return c;
    })();
    const toast = document.createElement("div");
    toast.classList.add("toast-message", type);
    const icon = {
      info: "info",
      success: "check_circle",
      error: "error"
    } [type];
    toast.innerHTML = `<span class="material-symbols-rounded">${icon}</span> ${DOMPurify.sanitize(message)}`;
    container.appendChild(toast);
    setTimeout(() => toast.classList.add("show"), 10);
    setTimeout(() => {
      toast.classList.remove("show");
      toast.addEventListener("transitionend", () => toast.remove(), {
        once: true
      });
    }, duration);
  };

  const showConfirm = (title, message, callback) => {
    createModal('confirm', title, message, callback);
  };

  const showPrompt = (title, defaultValue, callback) => {
    createModal('prompt', title, "", callback, defaultValue);
  };

  // --- Start the App ---
  initialize();
});
